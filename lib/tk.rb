# frozen_string_literal: false
#
#               tk.rb - Tk interface module using tcltklib
#                       by Yukihiro Matsumoto <matz@netlab.jp>

# use Shigehiro's tcltklib
require 'tcltklib'
require_relative 'tcltkip'             # TclTkIp Ruby extensions
require_relative 'tkcomm'
require_relative 'tk/tk_kernel'        # TkKernel base class
require_relative 'tk/tk_callback_entry' # TkCallbackEntry marker class
require_relative 'tk/util'             # TkUtil module (pure Ruby)
require_relative 'tkcore'              # TkCore module

# autoload
require 'tk/autoload'

# for Mutex
require 'thread'

# TclTkLib encoding methods - all UTF-8 now
module TclTkLib
  class << self
    def force_default_encoding=(mode); end
    def force_default_encoding? = true
    def default_encoding=(name); end
    def encoding=(name); end
    def encoding_name = 'utf-8'
    def encoding_obj = ::Encoding::UTF_8
    alias encoding encoding_name
    alias default_encoding encoding_name
  end
end

module Tk
  include TkCore
  extend Tk

  TCL_VERSION = INTERP._invoke_without_enc("info", "tclversion").freeze
  TCL_PATCHLEVEL = INTERP._invoke_without_enc("info", "patchlevel").freeze

  major, minor = TCL_VERSION.split('.')
  TCL_MAJOR_VERSION = major.to_i
  TCL_MINOR_VERSION = minor.to_i

  TK_VERSION  = INTERP._invoke_without_enc("set", "tk_version").freeze
  TK_PATCHLEVEL  = INTERP._invoke_without_enc("set", "tk_patchLevel").freeze

  major, minor = TK_VERSION.split('.')
  TK_MAJOR_VERSION = major.to_i
  TK_MINOR_VERSION = minor.to_i

  JAPANIZED_TK = (INTERP._invoke_without_enc("info", "commands",
                                             "kanji") != "").freeze

  # Auto-load version-specific generated options if available
  # Generated by: rake tk:generate_options
  begin
    version_const = TCL_VERSION.gsub('.', '_')
    require_relative "tk/generated/options_#{version_const}"
  rescue LoadError
    warn "[ruby-tk] Generated options not found for Tcl #{TCL_VERSION}. Run: rake tk:generate_options[#{TCL_VERSION}]"
  end

  def Tk.const_missing(sym)
    case(sym)
    when :TCL_LIBRARY
      INTERP._invoke_without_enc('global', 'tcl_library')
      INTERP._invoke("set", "tcl_library").freeze

    when :TK_LIBRARY
      INTERP._invoke_without_enc('global', 'tk_library')
      INTERP._invoke("set", "tk_library").freeze

    when :LIBRARY
      INTERP._invoke("info", "library").freeze

    #when :PKG_PATH, :PACKAGE_PATH, :TCL_PACKAGE_PATH
    #  INTERP._invoke_without_enc('global', 'tcl_pkgPath')
    #  tk_split_simplelist(INTERP._invoke('set', 'tcl_pkgPath'))

    #when :LIB_PATH, :LIBRARY_PATH, :TCL_LIBRARY_PATH
    #  INTERP._invoke_without_enc('global', 'tcl_libPath')
    #  tk_split_simplelist(INTERP._invoke('set', 'tcl_libPath'))

    when :PLATFORM, :TCL_PLATFORM
      INTERP._invoke_without_enc('global', 'tcl_platform')
      Hash[*tk_split_simplelist(INTERP._invoke_without_enc('array', 'get',
                                                           'tcl_platform'))]

    when :ENV
      INTERP._invoke_without_enc('global', 'env')
      Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', 'env'))]

    #when :AUTO_PATH   #<===
    #  tk_split_simplelist(INTERP._invoke('set', 'auto_path'))

    #when :AUTO_OLDPATH
    #  tk_split_simplelist(INTERP._invoke('set', 'auto_oldpath'))

    when :AUTO_INDEX
      INTERP._invoke_without_enc('global', 'auto_index')
      Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', 'auto_index'))]

    when :PRIV, :PRIVATE, :TK_PRIV
      priv = {}
      if INTERP._invoke_without_enc('info', 'vars', 'tk::Priv') != ""
        var_nam = 'tk::Priv'
      else
        var_nam = 'tkPriv'
      end
      INTERP._invoke_without_enc('global', var_nam)
      Hash[*tk_split_simplelist(INTERP._invoke('array', 'get',
                                               var_nam))].each{|k,v|
        k.freeze
        case v
        when /^-?\d+$/
          priv[k] = v.to_i
        when /^-?\d+\.?\d*(e[-+]?\d+)?$/
          priv[k] = v.to_f
        else
          priv[k] = v.freeze
        end
      }
      priv

    else
      raise NameError, 'uninitialized constant Tk::' + sym.id2name
    end
  end

  def Tk.errorInfo
    INTERP._invoke_without_enc('global', 'errorInfo')
    INTERP._invoke_without_enc('set', 'errorInfo')
  end

  def Tk.errorCode
    INTERP._invoke_without_enc('global', 'errorCode')
    code = tk_split_simplelist(INTERP._invoke_without_enc('set', 'errorCode'))
    case code[0]
    when 'CHILDKILLED', 'CHILDSTATUS', 'CHILDSUSP'
      begin
        pid = Integer(code[1])
        code[1] = pid
      rescue
      end
    end
    code
  end

  def Tk.has_mainwindow?
    INTERP.has_mainwindow?
  end

  def root
    Tk::Root.new
  end

  def Tk.load_tclscript(file, enc=nil)
    if enc
      # TCL_VERSION >= 8.5
      tk_call('source', '-encoding', enc, file)
    else
      tk_call('source', file)
    end
  end

  def Tk.load_tcllibrary(file, pkg_name=None, interp=None)
    tk_call('load', file, pkg_name, interp)
  end

  def Tk.unload_tcllibrary(*args)
    if args[-1].kind_of?(Hash)
      keys = _symbolkey2str(args.pop)
      nocomp = (keys['nocomplain'])? '-nocomplain': None
      keeplib = (keys['keeplibrary'])? '-keeplibrary': None
      tk_call('unload', nocomp, keeplib, '--', *args)
    else
      tk_call('unload', *args)
    end
  end

  def Tk.pkgconfig_list(mod)
    # Tk8.5 feature
    if mod.kind_of?(Module)
      if mod.respond_to?(:package_name)
        pkgname = mod.package_name
      elsif mod.const_defined?(:PACKAGE_NAME)
        pkgname = mod::PACKAGE_NAME
      else
        fail NotImplementedError, 'may not be a module for a Tcl extension'
      end
    else
      pkgname = mod.to_s
    end

    pkgname = '::' << pkgname unless pkgname =~ /^::/

    tk_split_list(tk_call(pkgname + '::pkgconfig', 'list'))
  end

  def Tk.pkgconfig_get(mod, key)
    # Tk8.5 feature
    if mod.kind_of?(Module)
      if mod.respond_to?(:package_name)
        pkgname = mod.package_name
      else
        fail NotImplementedError, 'may not be a module for a Tcl extension'
      end
    else
      pkgname = mod.to_s
    end

    pkgname = '::' << pkgname unless pkgname =~ /^::/

    tk_call(pkgname + '::pkgconfig', 'get', key)
  end

  def Tk.tcl_pkgconfig_list
    # Tk8.5 feature
    Tk.pkgconfig_list('::tcl')
  end

  def Tk.tcl_pkgconfig_get(key)
    # Tk8.5 feature
    Tk.pkgconfig_get('::tcl', key)
  end

  def Tk.tk_pkgconfig_list
    # Tk8.5 feature
    Tk.pkgconfig_list('::tk')
  end

  def Tk.tk_pkgconfig_get(key)
    # Tk8.5 feature
    Tk.pkgconfig_get('::tk', key)
  end

  def Tk.bell(nice = false)
    if nice
      tk_call_without_enc('bell', '-nice')
    else
      tk_call_without_enc('bell')
    end
    nil
  end

  def Tk.bell_on_display(win, nice = false)
    if nice
      tk_call_without_enc('bell', '-displayof', win, '-nice')
    else
      tk_call_without_enc('bell', '-displayof', win)
    end
    nil
  end

  def Tk.destroy(*wins)
    #tk_call_without_enc('destroy', *wins)
    tk_call_without_enc('destroy', *(wins.collect{|win|
                                       if win.kind_of?(TkWindow)
                                         win.epath
                                       else
                                         win
                                       end
                                     }))
  end

  def Tk.exit
    TkCore::INTERP.has_mainwindow? && tk_call_without_enc('destroy', '.')
  end

  ################################################

  def Tk.sleep(ms = nil, id = nil)
    if id
      var = (id.kind_of?(TkVariable))? id: TkVarAccess.new(id.to_s)
    else
      var = TkVariable.new
    end

    var.value = tk_call_without_enc('after', ms, proc{ var.value = 0 }) if ms
    var.thread_wait
    ms
  end

  def Tk.wakeup(id)
    ((id.kind_of?(TkVariable))? id: TkVarAccess.new(id.to_s)).value = 0
    nil
  end

  ################################################

  def Tk.pack(*args)
    TkPack.configure(*args)
  end
  def Tk.pack_forget(*args)
    TkPack.forget(*args)
  end
  def Tk.unpack(*args)
    TkPack.forget(*args)
  end

  def Tk.grid(*args)
    TkGrid.configure(*args)
  end
  def Tk.grid_forget(*args)
    TkGrid.forget(*args)
  end
  def Tk.ungrid(*args)
    TkGrid.forget(*args)
  end

  def Tk.place(*args)
    TkPlace.configure(*args)
  end
  def Tk.place_forget(*args)
    TkPlace.forget(*args)
  end
  def Tk.unplace(*args)
    TkPlace.forget(*args)
  end

  def Tk.update(idle=nil)
    if idle
      tk_call_without_enc('update', 'idletasks')
    else
      tk_call_without_enc('update')
    end
  end
  def Tk.update_idletasks
    update(true)
  end
  def update(idle=nil)
    # only for backward compatibility (This never be recommended to use)
    Tk.update(idle)
    self
  end

  # NOTE::
  #   If no eventloop-thread is running, "thread_update" method is same
  #   to "update" method. Else, "thread_update" method waits to complete
  #   idletask operation on the eventloop-thread.
  def Tk.thread_update(idle=nil)
    if idle
      tk_call_without_enc('thread_update', 'idletasks')
    else
      tk_call_without_enc('thread_update')
    end
  end
  def Tk.thread_update_idletasks
    thread_update(true)
  end

  def Tk.lower_window(win, below=None)
    tk_call('lower', _epath(win), _epath(below))
    nil
  end
  def Tk.raise_window(win, above=None)
    tk_call('raise', _epath(win), _epath(above))
    nil
  end

  def Tk.current_grabs(win = nil)
    if win
      window(tk_call_without_enc('grab', 'current', win))
    else
      tk_split_list(tk_call_without_enc('grab', 'current'))
    end
  end

  def Tk.focus(display=nil)
    if display == nil
      window(tk_call_without_enc('focus'))
    else
      window(tk_call_without_enc('focus', '-displayof', display))
    end
  end

  def Tk.focus_to(win, force=false)
    if force
      tk_call_without_enc('focus', '-force', win)
    else
      tk_call_without_enc('focus', win)
    end
  end

  def Tk.focus_lastfor(win)
    window(tk_call_without_enc('focus', '-lastfor', win))
  end

  def Tk.focus_next(win)
    TkManageFocus.next(win)
  end

  def Tk.focus_prev(win)
    TkManageFocus.prev(win)
  end

  def Tk.strictMotif(mode=None)
    bool(tk_call_without_enc('set', 'tk_strictMotif', mode))
  end

  def Tk.show_kinsoku(mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'show', mode))
      end
    rescue
    end
  end
  def Tk.add_kinsoku(chars, mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'add', mode,
                                    *(chars.split(''))))
      else
        []
      end
    rescue
      []
    end
  end
  def Tk.delete_kinsoku(chars, mode='both')
    begin
      if /^8\.*/ === TK_VERSION  && JAPANIZED_TK
        tk_split_simplelist(tk_call('kinsoku', 'delete', mode,
                            *(chars.split(''))))
      end
    rescue
    end
  end

  def Tk.toUTF8(str, encoding = nil)
    _toUTF8(str, encoding)
  end

  def Tk.fromUTF8(str, encoding = nil)
    _fromUTF8(str, encoding)
  end
end

# Tk::Encoding module loaded after TkCore is defined
require_relative 'tk/encoding'
require_relative 'tk/bind_core'
require_relative 'tk/treat_font'

module TkConfigMethod
  include TkUtil
  include TkTreatFont

  def __cget_cmd
    [self.path, 'cget']
  end
  private :__cget_cmd

  def __config_cmd
    [self.path, 'configure']
  end
  private :__config_cmd

  def __confinfo_cmd
    __config_cmd
  end
  private :__confinfo_cmd

  def __configinfo_struct
    {:key=>0, :alias=>1, :db_name=>1, :db_class=>2,
      :default_value=>3, :current_value=>4}
  end
  private :__configinfo_struct

  def __optkey_aliases
    if self.class.respond_to?(:declared_optkey_aliases)
      self.class.declared_optkey_aliases
    else
      {}
    end
  end
  private :__optkey_aliases

  # Look up a declared option and convert value using its from_tcl converter.
  # Returns [converted_value, true] if option is declared, [original_value, false] otherwise.
  def __convert_from_tcl(slot, value)
    return [value, false] unless self.class.respond_to?(:resolve_option)
    opt = self.class.resolve_option(slot)
    return [value, false] unless opt
    [opt.from_tcl(value, widget: self), true]
  end
  private :__convert_from_tcl

  # Look up a declared option and convert value using its to_tcl converter.
  # Returns [converted_value, true] if option is declared, [original_value, false] otherwise.
  def __convert_to_tcl(slot, value)
    return [value, false] unless self.class.respond_to?(:resolve_option)
    opt = self.class.resolve_option(slot)
    return [value, false] unless opt
    [opt.to_tcl(value, widget: self), true]
  end
  private :__convert_to_tcl

  def __val2ruby_optkeys  # { key=>proc, ... }
    # The method is used to convert a opt-value to a ruby's object.
    # When get the value of the option "key", "proc.call(value)" is called.
    {}
  end
  private :__val2ruby_optkeys

  def __ruby2val_optkeys  # { key=>proc, ... }
    # The method is used to convert a ruby's object to a opt-value.
    # When set the value of the option "key", "proc.call(value)" is called.
    # That is, "-#{key} #{proc.call(value)}".
    {}
  end
  private :__ruby2val_optkeys


  ################################

  def [](id)
    cget(id)
  end

  def []=(id, val)
    configure(id, val)
    val
  end

  def cget_tkstring(option)
    opt = option.to_s
    fail ArgumentError, "Invalid option `#{option.inspect}'" if opt.length == 0
    tk_call_without_enc(*(__cget_cmd << "-#{opt}"))
  end

  def __cget_core(slot)
    slot = slot.to_s
    fail ArgumentError, "Invalid option `#{slot.inspect}'" if slot.empty?

    # Resolve via Option registry (handles aliases too)
    opt = self.class.respond_to?(:resolve_option) && self.class.resolve_option(slot)
    slot = opt.tcl_name if opt

    # Font options (complex, keep for now)
    if slot =~ /^(#{__font_optkeys.join('|')})$/
      fnt = tk_tcl2ruby(tk_call_without_enc(*(__cget_cmd << "-#{slot}")), true)
      return fnt.kind_of?(TkFont) ? fnt : fontobj(slot)
    end

    # Get raw value from Tcl
    raw_value = tk_call_without_enc(*(__cget_cmd << "-#{slot}"))

    # Use Option registry for type conversion, otherwise return raw string
    if opt
      opt.from_tcl(raw_value, widget: self)
    else
      warn "#{self.class}#cget(:#{slot}) - option not declared, returning raw string"
      raw_value
    end
  end
  private :__cget_core

  def cget(slot)
    __cget_core(slot)
  end
  alias cget_strict cget

  # Check if an option requires a newer Tcl/Tk version.
  # If it does, emit a warning and return true (should skip this option).
  # Returns false if option is available or not version-restricted.
  def __skip_version_restricted_option?(option_name)
    return false unless self.class.respond_to?(:option_version_required)
    required_version = self.class.option_version_required(option_name)
    return false unless required_version

    warn "#{self.class}: option '#{option_name}' requires Tcl/Tk #{required_version}.0+ " \
         "(current: #{Tk::TK_VERSION}). Option ignored."
    true
  end
  private :__skip_version_restricted_option?

  def __configure_core(slot, value=None)
    if slot.kind_of? Hash
      slot = _symbolkey2str(slot)

      # Filter out version-restricted options before processing
      slot.delete_if { |k, _| __skip_version_restricted_option?(k) }

      __optkey_aliases.each{|alias_name, real_name|
        alias_name = alias_name.to_s
        if slot.has_key?(alias_name)
          slot[real_name.to_s] = slot.delete(alias_name)
        end
      }

      __ruby2val_optkeys.each{|key, method|
        key = key.to_s
        slot[key] = method.call(slot[key]) if slot.has_key?(key)
      }

      if (slot.find{|k, v| k =~ /^(|latin|ascii|kanji)(#{__font_optkeys.join('|')})$/})
        font_configure(slot)
      elsif slot.size > 0
        tk_call(*(__config_cmd.concat(hash_kv(slot))))
      end

    else
      orig_slot = slot
      slot = slot.to_s
      if slot.length == 0
        fail ArgumentError, "Invalid option `#{orig_slot.inspect}'"
      end

      _, real_name = __optkey_aliases.find{|k, v| k.to_s == slot}
      if real_name
        slot = real_name.to_s
      end

      # Check version restriction before attempting to configure
      return self if __skip_version_restricted_option?(slot)

      if ( method = _symbolkey2str(__ruby2val_optkeys)[slot] )
        tk_call(*(__config_cmd << "-#{slot}" << method.call(value)))
      elsif (slot =~ /^(|latin|ascii|kanji)(#{__font_optkeys.join('|')})$/)
        if value == None
          fontobj($2)
        else
          font_configure({slot=>value})
        end
      else
        tk_call(*(__config_cmd << "-#{slot}" << value))
      end
    end
    self
  end
  private :__configure_core

  def configure(slot, value=None)
    __configure_core(slot, value)
    self
  end

  def configure_cmd(slot, value)
    configure(slot, install_cmd(value))
  end

  # Apply Option registry type conversion to configinfo array values.
  # Converts default_value and current_value slots using the Option's from_tcl method.
  def __apply_configinfo_conversion(conf, slot)
    return conf unless self.class.respond_to?(:resolve_option)
    opt = self.class.resolve_option(slot)
    return conf unless opt

    dv_idx = __configinfo_struct[:default_value]
    cv_idx = __configinfo_struct[:current_value]

    if dv_idx && conf[dv_idx]
      conf[dv_idx] = opt.from_tcl(conf[dv_idx], widget: self) rescue conf[dv_idx]
    end
    if cv_idx && conf[cv_idx]
      conf[cv_idx] = opt.from_tcl(conf[cv_idx], widget: self) rescue conf[cv_idx]
    end
    conf
  end
  private :__apply_configinfo_conversion

  def __configinfo_core(slot = nil)
    if TkComm::GET_CONFIGINFO_AS_ARRAY
      __configinfo_core_array(slot)
    else
      __configinfo_core_hash(slot)
    end
  end

  # Array mode: returns [key, dbname, dbclass, default_value, current_value]
  def __configinfo_core_array(slot)
    # Font option handling (complex, keep for now)
    if slot && slot.to_s =~ /^(|latin|ascii|kanji)(#{__font_optkeys.join('|')})$/
      fontkey = $2
      conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{fontkey}")), false, true)
      conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
      if !__configinfo_struct[:alias] || conf.size > __configinfo_struct[:alias] + 1
        fnt = conf[__configinfo_struct[:default_value]]
        conf[__configinfo_struct[:default_value]] = TkNamedFont.new(fnt) if TkFont.is_system_font?(fnt)
        conf[__configinfo_struct[:current_value]] = fontobj(fontkey)
      elsif __configinfo_struct[:alias] && conf.size == __configinfo_struct[:alias] + 1 &&
            conf[__configinfo_struct[:alias]][0] == ?-
        conf[__configinfo_struct[:alias]] = conf[__configinfo_struct[:alias]][1..-1]
      end
      return conf
    end

    if slot
      slot = slot.to_s
      # Resolve aliases
      _, real_name = __optkey_aliases.find { |k, _| k.to_s == slot }
      slot = real_name.to_s if real_name

      # Try Option registry first
      opt = self.class.respond_to?(:resolve_option) && self.class.resolve_option(slot)
      if opt
        conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{slot}")), false, true)
        conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
        conf = __apply_configinfo_conversion(conf, slot)
        return __strip_alias_dash(conf)
      end

      # No Option declared - return raw values with warning
      warn "#{self.class}#configinfo(:#{slot}) - option not declared, returning raw"
      conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{slot}")), false, true)
      conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
      __strip_alias_dash(conf)
    else
      # All options
      ret = tk_split_simplelist(tk_call_without_enc(*__confinfo_cmd), false, false).collect do |conflist|
        conf = tk_split_simplelist(conflist, false, true)
        conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
        optkey = conf[__configinfo_struct[:key]]

        # Try Option registry first
        opt = self.class.respond_to?(:resolve_option) && self.class.resolve_option(optkey)
        if opt
          conf = __apply_configinfo_conversion(conf, optkey)
        else
          # No Option declared - leave raw values (warn once per class)
          @__undeclared_options_warned ||= {}
          unless @__undeclared_options_warned[optkey]
            warn "#{self.class}#configinfo - option '#{optkey}' not declared"
            @__undeclared_options_warned[optkey] = true
          end
        end
        __strip_alias_dash(conf)
      end

      # Font post-processing
      __font_optkeys.each do |optkey|
        optkey = optkey.to_s
        fontconf = ret.assoc(optkey)
        if fontconf && fontconf.size > 2
          ret.delete_if { |inf| inf[0] =~ /^(|latin|ascii|kanji)#{optkey}$/ }
          fnt = fontconf[__configinfo_struct[:default_value]]
          fontconf[__configinfo_struct[:default_value]] = TkNamedFont.new(fnt) if TkFont.is_system_font?(fnt)
          fontconf[__configinfo_struct[:current_value]] = fontobj(optkey)
          ret.push(fontconf)
        end
      end

      ret
    end
  end
  private :__configinfo_core_array

  # Hash mode: returns {key => [dbname, dbclass, default_value, current_value]}
  def __configinfo_core_hash(slot)
    # Font option handling
    if slot && slot.to_s =~ /^(|latin|ascii|kanji)(#{__font_optkeys.join('|')})$/
      fontkey = $2
      conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{fontkey}")), false, true)
      conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
      if !__configinfo_struct[:alias] || conf.size > __configinfo_struct[:alias] + 1
        fnt = conf[__configinfo_struct[:default_value]]
        conf[__configinfo_struct[:default_value]] = TkNamedFont.new(fnt) if TkFont.is_system_font?(fnt)
        conf[__configinfo_struct[:current_value]] = fontobj(fontkey)
        return { conf.shift => conf }
      elsif __configinfo_struct[:alias] && conf.size == __configinfo_struct[:alias] + 1
        conf[__configinfo_struct[:alias]] = conf[__configinfo_struct[:alias]][1..-1] if conf[__configinfo_struct[:alias]][0] == ?-
        return { conf[0] => conf[1] }
      else
        return { conf.shift => conf }
      end
    end

    if slot
      slot = slot.to_s
      _, real_name = __optkey_aliases.find { |k, _| k.to_s == slot }
      slot = real_name.to_s if real_name

      # Try Option registry
      opt = self.class.respond_to?(:resolve_option) && self.class.resolve_option(slot)
      if opt
        conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{slot}")), false, true)
        conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
        conf = __apply_configinfo_conversion(conf, slot)
        return __format_hash_result(conf)
      end

      # No Option declared - return raw values with warning
      warn "#{self.class}#configinfo(:#{slot}) - option not declared, returning raw"
      conf = tk_split_simplelist(tk_call_without_enc(*(__confinfo_cmd << "-#{slot}")), false, true)
      conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
      __format_hash_result(conf)
    else
      ret = {}
      tk_split_simplelist(tk_call_without_enc(*__confinfo_cmd), false, false).each do |conflist|
        conf = tk_split_simplelist(conflist, false, true)
        conf[__configinfo_struct[:key]] = conf[__configinfo_struct[:key]][1..-1]
        optkey = conf[__configinfo_struct[:key]]

        opt = self.class.respond_to?(:resolve_option) && self.class.resolve_option(optkey)
        if opt
          conf = __apply_configinfo_conversion(conf, optkey)
        else
          # No Option declared - leave raw values (warn once per class)
          @__undeclared_options_warned ||= {}
          unless @__undeclared_options_warned[optkey]
            warn "#{self.class}#configinfo - option '#{optkey}' not declared"
            @__undeclared_options_warned[optkey] = true
          end
        end
        ret.merge!(__format_hash_result(conf))
      end

      # Font post-processing
      __font_optkeys.each do |optkey|
        optkey = optkey.to_s
        next unless ret.key?(optkey) && ret[optkey].is_a?(Array) && ret[optkey].size > 1
        ret.delete_if { |k, _| k =~ /^(latin|ascii|kanji)#{optkey}$/ }
        fnt = ret[optkey][__configinfo_struct[:default_value] - 1] rescue nil
        ret[optkey][__configinfo_struct[:default_value] - 1] = TkNamedFont.new(fnt) if fnt && TkFont.is_system_font?(fnt)
        ret[optkey][__configinfo_struct[:current_value] - 1] = fontobj(optkey) rescue nil
      end

      ret
    end
  end
  private :__configinfo_core_hash

  # Strip leading dash from alias target if present
  # Alias entries are 2-element arrays: ["bd", "-borderwidth"] -> ["bd", "borderwidth"]
  def __strip_alias_dash(conf)
    if conf.size == 2 && conf[1].is_a?(String) && conf[1].start_with?('-')
      conf[1] = conf[1][1..-1]
    end
    conf
  end
  private :__strip_alias_dash

  # Format config array as hash result
  def __format_hash_result(conf)
    if __configinfo_struct[:alias] && conf.size == __configinfo_struct[:alias] + 1
      conf[__configinfo_struct[:alias]] = conf[__configinfo_struct[:alias]][1..-1] if conf[__configinfo_struct[:alias]][0] == ?-
      { conf[0] => conf[1] }
    else
      { conf.shift => conf }
    end
  end
  private :__format_hash_result

  private :__configinfo_core

  def configinfo(slot = nil)
    __configinfo_core(slot)
  end

  def current_configinfo(slot = nil)
    if TkComm::GET_CONFIGINFO_AS_ARRAY
      if slot
        org_slot = slot
        begin
          conf = configinfo(slot)
          if ( ! __configinfo_struct[:alias] \
              || conf.size > __configinfo_struct[:alias] + 1 )
            return {conf[0] => conf[-1]}
          end
          slot = conf[__configinfo_struct[:alias]]
        end while(org_slot != slot)
        fail RuntimeError,
          "there is a configure alias loop about '#{org_slot}'"
      else
        ret = {}
        configinfo().each{|cnf|
          if ( ! __configinfo_struct[:alias] \
              || cnf.size > __configinfo_struct[:alias] + 1 )
            ret[cnf[0]] = cnf[-1]
          end
        }
        ret
      end
    else # ! TkComm::GET_CONFIGINFO_AS_ARRAY
      ret = {}
      configinfo(slot).each{|key, cnf|
        ret[key] = cnf[-1] if cnf.kind_of?(Array)
      }
      ret
    end
  end
end

require_relative 'tkobject'
require_relative 'tkwindow'

TkWidget = TkWindow

# freeze core modules
#TclTkLib.freeze
#TclTkIp.freeze
#TkUtil.freeze
#TkKernel.freeze
#TkComm.freeze
#TkComm::Event.freeze
#TkCore.freeze
#Tk.freeze

module Tk
  RELEASE_DATE = '2014-10-19'.freeze

  autoload :AUTO_PATH,        'tk/variable'
  autoload :TCL_PACKAGE_PATH, 'tk/variable'
  autoload :PACKAGE_PATH,     'tk/variable'
  autoload :TCL_LIBRARY_PATH, 'tk/variable'
  autoload :LIBRARY_PATH,     'tk/variable'
  autoload :TCL_PRECISION,    'tk/variable'
end

# call setup script for Tk extension libraries (base configuration)
begin
  require 'tkextlib/version.rb'
  require 'tkextlib/setup.rb'
rescue LoadError
  # ignore
end
