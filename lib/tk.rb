# frozen_string_literal: false
#
#               tk.rb - Tk interface module using tcltklib
#                       by Yukihiro Matsumoto <matz@netlab.jp>

# use Shigehiro's tcltklib
require 'tcltklib'
require_relative 'tcltkip'             # TclTkIp Ruby extensions
require_relative 'tkcomm'
require_relative 'tk/tk_kernel'        # TkKernel base class
require_relative 'tk/tk_callback_entry' # TkCallbackEntry marker class
require_relative 'tk/util'             # TkUtil module (pure Ruby)
require_relative 'tk/warnings'         # Tk::Warnings module
require_relative 'tkcore'              # TkCore module

# autoload
require 'tk/autoload'

# for Mutex
require 'thread'

# TclTkLib encoding methods - all UTF-8 now
module TclTkLib
  class << self
    def force_default_encoding=(mode); end
    def force_default_encoding? = true
    def default_encoding=(name); end
    def encoding=(name); end
    def encoding_name = 'utf-8'
    def encoding_obj = ::Encoding::UTF_8
    alias encoding encoding_name
    alias default_encoding encoding_name
  end
end

module Tk
  include TkCore
  extend Tk


  TCL_VERSION = INTERP._invoke_without_enc("info", "tclversion").freeze
  TCL_PATCHLEVEL = INTERP._invoke_without_enc("info", "patchlevel").freeze

  major, minor = TCL_VERSION.split('.')
  TCL_MAJOR_VERSION = major.to_i
  TCL_MINOR_VERSION = minor.to_i

  TK_VERSION  = INTERP._invoke_without_enc("set", "tk_version").freeze
  TK_PATCHLEVEL  = INTERP._invoke_without_enc("set", "tk_patchLevel").freeze

  major, minor = TK_VERSION.split('.')
  TK_MAJOR_VERSION = major.to_i
  TK_MINOR_VERSION = minor.to_i

  # Behavior when code uses options from newer Tk versions
  # :warn   - log warning and strip option (default)
  # :ignore - silently strip option
  # :raise  - raise error
  @version_mismatch = :warn

  class << self
    def version_mismatch
      @version_mismatch
    end

    def version_mismatch=(mode)
      unless %i[warn ignore raise].include?(mode)
        raise ArgumentError, "version_mismatch must be :warn, :ignore, or :raise"
      end
      @version_mismatch = mode
    end

    # Control error handling in background Ractor/thread work
    # false (default): errors are warned but don't stop the app
    # true: errors raise an exception (useful for debugging)
    def abort_on_ractor_error
      @abort_on_ractor_error ||= false
    end

    def abort_on_ractor_error=(value)
      @abort_on_ractor_error = !!value
    end
  end

  # Auto-load version-specific generated options if available
  # Generated by: rake tk:generate_options
  version_const = TCL_VERSION.gsub('.', '_')
  begin
    require_relative "tk/generated/options_#{version_const}"
  rescue LoadError
    warn "[ruby-tk] Generated options not found for Tcl #{TCL_VERSION}. Run: rake tk:generate_options[#{TCL_VERSION}]"
  end

  # Auto-load version-specific generated item options if available
  # Generated by: rake tk:generate_item_options
  begin
    require_relative "tk/generated/item_options_#{version_const}"
  rescue LoadError
    warn "[ruby-tk] Generated item options not found for Tcl #{TCL_VERSION}. Run: rake tk:generate_item_options[#{TCL_VERSION}]"
  end

  # Auto-load version-specific generated Ttk options if available
  # Generated by: rake tk:generate_ttk_options
  begin
    require_relative "tk/generated/ttk_options_#{version_const}"
  rescue LoadError
    # Ttk options are optional - only warn in verbose mode
    warn "[ruby-tk] Generated Ttk options not found for Tcl #{TCL_VERSION}. Run: rake tk:generate_ttk_options" if $VERBOSE
  end

  # --- Tcl variable accessors ---
  # These replace the old const_missing hack with proper methods.

  def Tk.tcl_library
    INTERP._invoke_without_enc('global', 'tcl_library')
    INTERP._invoke("set", "tcl_library").freeze
  end

  def Tk.tk_library
    INTERP._invoke_without_enc('global', 'tk_library')
    INTERP._invoke("set", "tk_library").freeze
  end

  def Tk.library
    INTERP._invoke("info", "library").freeze
  end

  def Tk.platform
    INTERP._invoke_without_enc('global', 'tcl_platform')
    Hash[*tk_split_simplelist(INTERP._invoke_without_enc('array', 'get', 'tcl_platform'))]
  end

  def Tk.tcl_env
    INTERP._invoke_without_enc('global', 'env')
    Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', 'env'))]
  end

  def Tk.auto_index
    INTERP._invoke_without_enc('global', 'auto_index')
    Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', 'auto_index'))]
  end

  def Tk.priv
    var_nam = if INTERP._invoke_without_enc('info', 'vars', 'tk::Priv') != ""
                'tk::Priv'
              else
                'tkPriv'
              end
    INTERP._invoke_without_enc('global', var_nam)
    result = {}
    Hash[*tk_split_simplelist(INTERP._invoke('array', 'get', var_nam))].each do |k, v|
      k.freeze
      result[k] = case v
                  when /^-?\d+$/ then v.to_i
                  when /^-?\d+\.?\d*(e[-+]?\d+)?$/ then v.to_f
                  else v.freeze
                  end
    end
    result
  end

  # Deprecated: const_missing fallback for legacy code using Tk::TCL_LIBRARY, etc.
  CONST_MISSING_MAP = {
    TCL_LIBRARY: :tcl_library,
    TK_LIBRARY: :tk_library,
    LIBRARY: :library,
    PLATFORM: :platform,
    TCL_PLATFORM: :platform,
    ENV: :tcl_env,
    AUTO_INDEX: :auto_index,
    PRIV: :priv,
    PRIVATE: :priv,
    TK_PRIV: :priv
  }.freeze

  def Tk.const_missing(sym)
    if (method_name = CONST_MISSING_MAP[sym])
      warn "Tk::#{sym} is deprecated. Use Tk.#{method_name} instead.", uplevel: 1
      send(method_name)
    else
      raise NameError, "uninitialized constant Tk::#{sym}"
    end
  end

  # Compatibility: UTF8_String is no longer needed in Ruby 3.x (strings are UTF-8).
  # This converts \uXXXX escapes in single-quoted strings for old demo compatibility.
  class UTF8_String < String
    def initialize(str)
      Tk::Warnings.warn_once(:utf8_string,
        "Tk::UTF8_String is deprecated. Use regular Ruby strings (already UTF-8).")
      # Convert \uXXXX escapes (from single-quoted strings) to actual unicode
      converted = str.gsub(/\\u([0-9a-fA-F]{4})/) { [$1.to_i(16)].pack('U') }
      super(converted)
    end
  end

  # Module function form: Tk::UTF8_String("text")
  def Tk.UTF8_String(str)
    UTF8_String.new(str)
  end

  def Tk.errorInfo
    INTERP._invoke_without_enc('global', 'errorInfo')
    INTERP._invoke_without_enc('set', 'errorInfo')
  end

  def Tk.errorCode
    INTERP._invoke_without_enc('global', 'errorCode')
    code = tk_split_simplelist(INTERP._invoke_without_enc('set', 'errorCode'))
    case code[0]
    when 'CHILDKILLED', 'CHILDSTATUS', 'CHILDSUSP'
      begin
        pid = Integer(code[1])
        code[1] = pid
      rescue
      end
    end
    code
  end

  def Tk.has_mainwindow?
    # Check if main window "." exists using Tcl's winfo command
    tk_call_without_enc('winfo', 'exists', '.') == '1'
  rescue
    false
  end

  def root
    Tk::Root.new
  end

  def Tk.load_tclscript(file, enc=nil)
    if enc
      # TCL_VERSION >= 8.5
      tk_call('source', '-encoding', enc, file)
    else
      tk_call('source', file)
    end
  end

  def Tk.load_tcllibrary(file, pkg_name=None, interp=None)
    tk_call('load', file, pkg_name, interp)
  end

  def Tk.unload_tcllibrary(*args)
    if args[-1].kind_of?(Hash)
      keys = _symbolkey2str(args.pop)
      nocomp = (keys['nocomplain'])? '-nocomplain': None
      keeplib = (keys['keeplibrary'])? '-keeplibrary': None
      tk_call('unload', nocomp, keeplib, '--', *args)
    else
      tk_call('unload', *args)
    end
  end

  def Tk.pkgconfig_list(mod)
    # Tk8.5 feature
    if mod.kind_of?(Module)
      if mod.respond_to?(:package_name)
        pkgname = mod.package_name
      elsif mod.const_defined?(:PACKAGE_NAME)
        pkgname = mod::PACKAGE_NAME
      else
        fail NotImplementedError, 'may not be a module for a Tcl extension'
      end
    else
      pkgname = mod.to_s
    end

    pkgname = '::' << pkgname unless pkgname =~ /^::/

    tk_split_list(tk_call(pkgname + '::pkgconfig', 'list'))
  end

  def Tk.pkgconfig_get(mod, key)
    # Tk8.5 feature
    if mod.kind_of?(Module)
      if mod.respond_to?(:package_name)
        pkgname = mod.package_name
      else
        fail NotImplementedError, 'may not be a module for a Tcl extension'
      end
    else
      pkgname = mod.to_s
    end

    pkgname = '::' << pkgname unless pkgname =~ /^::/

    tk_call(pkgname + '::pkgconfig', 'get', key)
  end

  def Tk.tcl_pkgconfig_list
    # Tk8.5 feature
    Tk.pkgconfig_list('::tcl')
  end

  def Tk.tcl_pkgconfig_get(key)
    # Tk8.5 feature
    Tk.pkgconfig_get('::tcl', key)
  end

  def Tk.tk_pkgconfig_list
    # Tk8.5 feature
    Tk.pkgconfig_list('::tk')
  end

  def Tk.tk_pkgconfig_get(key)
    # Tk8.5 feature
    Tk.pkgconfig_get('::tk', key)
  end

  def Tk.bell(nice = false)
    if nice
      tk_call_without_enc('bell', '-nice')
    else
      tk_call_without_enc('bell')
    end
    nil
  end

  def Tk.bell_on_display(win, nice = false)
    if nice
      tk_call_without_enc('bell', '-displayof', win, '-nice')
    else
      tk_call_without_enc('bell', '-displayof', win)
    end
    nil
  end

  def Tk.destroy(*wins)
    #tk_call_without_enc('destroy', *wins)
    tk_call_without_enc('destroy', *(wins.collect{|win|
                                       if win.kind_of?(TkWindow)
                                         win.epath
                                       else
                                         win
                                       end
                                     }))
  end

  def Tk.exit
    Tk.has_mainwindow? && tk_call_without_enc('destroy', '.')
  end

  ################################################

  def Tk.sleep(ms = nil, id = nil)
    if id
      var = (id.kind_of?(TkVariable))? id: TkVarAccess.new(id.to_s)
    else
      var = TkVariable.new
    end

    var.value = tk_call_without_enc('after', ms, proc{ var.value = 0 }) if ms
    var.thread_wait
    ms
  end

  def Tk.wakeup(id)
    ((id.kind_of?(TkVariable))? id: TkVarAccess.new(id.to_s)).value = 0
    nil
  end

  ################################################

  def Tk.pack(*args)
    TkPack.configure(*args)
  end
  def Tk.pack_forget(*args)
    TkPack.forget(*args)
  end
  def Tk.unpack(*args)
    TkPack.forget(*args)
  end

  def Tk.grid(*args)
    TkGrid.configure(*args)
  end
  def Tk.grid_forget(*args)
    TkGrid.forget(*args)
  end
  def Tk.ungrid(*args)
    TkGrid.forget(*args)
  end

  def Tk.place(*args)
    TkPlace.configure(*args)
  end
  def Tk.place_forget(*args)
    TkPlace.forget(*args)
  end
  def Tk.unplace(*args)
    TkPlace.forget(*args)
  end

  def Tk.update(idle=nil)
    if idle
      tk_call_without_enc('update', 'idletasks')
    else
      tk_call_without_enc('update')
    end
  end
  def Tk.update_idletasks
    update(true)
  end
  def update(idle=nil)
    # only for backward compatibility (This never be recommended to use)
    Tk::Warnings.warn_once(:instance_update,
      "Calling #update on a Tk widget instance is deprecated. Use Tk.update instead.")
    Tk.update(idle)
    self
  end

  # NOTE: thread_update was a custom Tcl command in the legacy C extension.
  # It no longer exists - these methods now just delegate to regular update.
  def Tk.thread_update(idle=nil)
    Tk::Warnings.warn_once(:thread_update,
      "Tk.thread_update is deprecated and now just calls Tk.update. " \
      "The underlying 'thread_update' Tcl command no longer exists.")
    update(idle)
  end
  def Tk.thread_update_idletasks
    thread_update(true)
  end

  def Tk.lower_window(win, below=None)
    tk_call('lower', _epath(win), _epath(below))
    nil
  end
  def Tk.raise_window(win, above=None)
    tk_call('raise', _epath(win), _epath(above))
    nil
  end

  def Tk.current_grabs(win = nil)
    if win
      window(tk_call_without_enc('grab', 'current', win))
    else
      tk_split_list(tk_call_without_enc('grab', 'current'))
    end
  end

  def Tk.focus(display=nil)
    if display == nil
      window(tk_call_without_enc('focus'))
    else
      window(tk_call_without_enc('focus', '-displayof', display))
    end
  end

  def Tk.focus_to(win, force=false)
    if force
      tk_call_without_enc('focus', '-force', win)
    else
      tk_call_without_enc('focus', win)
    end
  end

  def Tk.focus_lastfor(win)
    window(tk_call_without_enc('focus', '-lastfor', win))
  end

  def Tk.focus_next(win)
    TkManageFocus.next(win)
  end

  def Tk.focus_prev(win)
    TkManageFocus.prev(win)
  end

  def Tk.strictMotif(mode=None)
    bool(tk_call_without_enc('set', 'tk_strictMotif', mode))
  end

  def Tk.toUTF8(str, encoding = nil)
    Tk::Warnings.warn_once(:to_utf8,
      "Tk.toUTF8 is deprecated. Ruby strings are already UTF-8.")
    str.to_s
  end

  def Tk.fromUTF8(str, encoding = nil)
    Tk::Warnings.warn_once(:from_utf8,
      "Tk.fromUTF8 is deprecated. Ruby strings are already UTF-8.")
    str.to_s
  end

  # Essential encoding methods - modern Ruby/Tcl use UTF-8 natively
  def Tk.encoding
    'utf-8'
  end

  def Tk.encoding_name
    'utf-8'
  end

  def Tk.encoding_system
    'utf-8'
  end

  def Tk.encoding_obj
    ::Encoding::UTF_8
  end

  def Tk.encoding_system_obj
    ::Encoding::UTF_8
  end

  def Tk.tk_encoding_names
    TkComm.simplelist(TkCore::INTERP._invoke_without_enc('encoding', 'names'))
  end

  def Tk.encoding_names
    tk_encoding_names
  end
end

require_relative 'tk/bind_core'

require_relative 'tkobject'
require_relative 'tkwindow'

TkWidget = TkWindow

# freeze core modules
#TclTkLib.freeze
#TclTkIp.freeze
#TkUtil.freeze
#TkKernel.freeze
#TkComm.freeze
#TkComm::Event.freeze
#TkCore.freeze
#Tk.freeze

module Tk
  RELEASE_DATE = '2014-10-19'.freeze

  autoload :AUTO_PATH,        'tk/variable'
  autoload :TCL_PACKAGE_PATH, 'tk/variable'
  autoload :PACKAGE_PATH,     'tk/variable'
  autoload :TCL_LIBRARY_PATH, 'tk/variable'
  autoload :LIBRARY_PATH,     'tk/variable'
  autoload :TCL_PRECISION,    'tk/variable'
end

# call setup script for Tk extension libraries (base configuration)
begin
  require 'tkextlib/version.rb'
  require 'tkextlib/setup.rb'
rescue LoadError
  # ignore
end
