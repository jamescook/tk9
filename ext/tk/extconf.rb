# frozen_string_literal: true

require 'mkmf'

# Always use stubs - no option to disable
$CFLAGS << " -DUSE_TCL_STUBS -DUSE_TK_STUBS"

def find_tcltk
  # Try pkg-config first
  tcl_found = pkg_config('tcl') || pkg_config('tcl9.0') || pkg_config('tcl8.6')
  tk_found = pkg_config('tk') || pkg_config('tk9.0') || pkg_config('tk8.6')

  unless tcl_found && tk_found
    # Manual search paths
    tcl_dirs = [
      '/opt/homebrew/opt/tcl-tk',
      '/usr/local/opt/tcl-tk',
      '/usr/local',
      '/usr'
    ]

    tcl_dirs.each do |dir|
      inc = "#{dir}/include"
      lib = "#{dir}/lib"
      # Check for tcl-tk subdirectory (Homebrew layout)
      if File.exist?("#{inc}/tcl-tk/tcl.h")
        inc = "#{inc}/tcl-tk"
      end
      if File.exist?("#{inc}/tcl.h") && File.exist?("#{inc}/tk.h")
        $INCFLAGS << " -I#{inc}"
        $LDFLAGS << " -L#{lib}"
        break
      end
    end
  end

  # Check for required headers
  have_header('tcl.h') or abort "tcl.h not found"
  have_header('tk.h') or abort "tk.h not found"

  # Link against STUB libraries, not main libraries
  # Try versioned stub names first, then unversioned
  tcl_stub = have_library('tclstub9.0') ||
             have_library('tclstub8.6') ||
             have_library('tclstub')

  tk_stub = have_library('tkstub9.0') ||
            have_library('tkstub8.6') ||
            have_library('tkstub')

  # If stub libraries not found by simple name, try via pkg-config
  unless tcl_stub
    # pkg-config may have added them already via --libs
    # Check if we can find the stubs table
    if try_link(<<~CODE)
      #define USE_TCL_STUBS
      #include <tcl.h>
      int main() { return 0; }
    CODE
      tcl_stub = true
    end
  end

  abort "Tcl stub library not found" unless tcl_stub
  abort "Tk stub library not found" unless tk_stub
end

find_tcltk

# Only compile the new bridge, not the old tcltklib.c
$srcs = ['tcltkbridge.c']

# ---------------------------------------------------------------------
# Generate tcltk_version.rb with compile-time version info
#
# WHY: Tcl's stubs mechanism turns all functions (including Tcl_GetVersion)
# into macros that dereference a function pointer table. That table is NULL
# until Tcl_InitStubs is called with an interpreter. But TclTkLib.get_version
# is called at module load time, before any interpreter exists.
#
# Rather than hack around stubs (temp interpreter, #undef, etc), we detect
# the version at gem install time from Tcl's header macros and generate a
# simple Ruby constant. Clean and no runtime stubs dependency.
# ---------------------------------------------------------------------

def detect_tcl_version
  # TCL_MAJOR_VERSION, TCL_MINOR_VERSION, TCL_RELEASE_LEVEL, TCL_RELEASE_SERIAL
  # are defined in tcl.h
  major = try_constant('TCL_MAJOR_VERSION', 'tcl.h')
  minor = try_constant('TCL_MINOR_VERSION', 'tcl.h')
  release_level = try_constant('TCL_RELEASE_LEVEL', 'tcl.h')
  release_serial = try_constant('TCL_RELEASE_SERIAL', 'tcl.h')

  unless major && minor && release_level && release_serial
    abort "Could not detect Tcl version from headers"
  end

  [major, minor, release_level, release_serial]
end

major, minor, release_level, patchlevel = detect_tcl_version
puts "Detected Tcl version: #{major}.#{minor}.#{patchlevel} (release_level=#{release_level})"

version_rb = File.expand_path('../../lib/tcltk_version.rb', __dir__)
File.write(version_rb, <<~RUBY)
  # frozen_string_literal: true
  # Auto-generated by extconf.rb at gem install time - do not edit
  #
  # Tcl version detected from headers. See extconf.rb for why this exists
  # (stubs mechanism prevents runtime version query before interpreter init).

  module TclTkLib
    # Release type constants (stable since Tcl 8.0)
    module RELEASE_TYPE
      ALPHA = 0
      BETA  = 1
      FINAL = 2
    end

    # [major, minor, release_type, patchlevel] - matches legacy get_version format
    TCL_VERSION_INFO = [#{major}, #{minor}, #{release_level}, #{patchlevel}].freeze

    def self.get_version
      TCL_VERSION_INFO
    end

    # TODO: Evaluate if this is needed in our simplified bridge design.
    # Legacy code uses this as a Tcl proc name for cleanup when interpreter
    # is deleted (unbinds destroy hooks to avoid SEGV). May be unnecessary
    # if the app is pure Tk, but possibly needed for mixed Ruby/Tk apps
    # that need graceful cleanup. From 2005 - "avoid SEGV trouble".
    FINALIZE_PROC_NAME = "INTERP_FINALIZE_HOOK"
  end
RUBY
puts "Generated #{version_rb}"

create_makefile('tcltklib')
